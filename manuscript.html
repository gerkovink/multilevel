<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Hanne Oberman">

<title>Imputation of incomplete multilevel data</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="manuscript_files/libs/clipboard/clipboard.min.js"></script>
<script src="manuscript_files/libs/quarto-html/quarto.js"></script>
<script src="manuscript_files/libs/quarto-html/popper.min.js"></script>
<script src="manuscript_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="manuscript_files/libs/quarto-html/anchor.min.js"></script>
<link href="manuscript_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="manuscript_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="manuscript_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="manuscript_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="manuscript_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Imputation of incomplete multilevel data</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Hanne Oberman </p>
          </div>
  </div>
    
  
    
  </div>
  

</header>

<section id="outline" class="level1">
<h1>Outline</h1>
<ul>
<li>motivation and intended audience</li>
<li>the mice framework/package</li>
<li>background info on missingness mechanisms etc.</li>
<li>case study</li>
</ul>
</section>
<section id="intended-audience" class="level1">
<h1>Intended audience</h1>
<p>This tutorial aims to serve analysts who know their way around multilevel modeling, but are not (as) familiar with missing data imputation.</p>
</section>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<ol type="1">
<li>missing data occur often in data with human subjects</li>
<li>missing data may be resolved, but need to be handled in accordance with the analysis of scientific interest</li>
<li>in human-subjects research, there is often clustering, which may be captured with multilevel modeling techniques</li>
<li>if the analysis of scientific interest is a multilevel model, the missing data handling method should accommodate the multilevel structure of the data</li>
<li>both missingness and multilevel structures require advanced statistical techniques</li>
<li>this tutorial sets out to facilitate empirical researchers in accommodating both multilevel structures as well as missing data</li>
<li>we illustrate the use of the software by means of a case study</li>
</ol>
</section>
<section id="methods" class="level1">
<h1>Methods</h1>
<p>The <span class="proglang"><code>R</code></span> package <span class="pkg"><code>mice</code></span> provides a framework for imputing incomplete data on a variable-by-variable basis. The <span class="fct"><code>mice</code></span> function allows users to flexibly specify how many times and under what model the missing data should be imputed. This is reflected in the first four function arguments</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="fu">mice</span>(data, m, method, predictorMatrix, ...)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>where <code>data</code> refers to the incomplete dataset, <code>m</code> determines the number of imputations, <code>method</code> denotes the functional form of the imputation model per variable and <code>predictorMatrix</code> specifies the interrelational dependencies between the variables and imputation models (i.e., the set of predictors to be used for imputing each incomplete variable).</p>
<p>The object supplied as <code>data</code> should be tabular (e.g.&nbsp;a <code>data.frame</code> with <span class="math inline">\(n\)</span> rows and <span class="math inline">\(p\)</span> variables, with missing values coded as <code>NA</code>). For multilevel imputation models, a numeric clustering variable is required.</p>
<p>The number of imputations <code>m</code> should be determined based on the severity of the missing data problem and the intended analysis model of substantive interest. Van Buuren (2018, <span class="math inline">\(\S\)</span> 2.8) suggests using the default <code>m = 5</code> for imputation model building, and to increase <code>m</code> as required after initial exploration.</p>
<p>The <code>method</code> argument specifies the imputation method to be used for each column in data. If not supplied by the user, <code>method</code> defaults to convenient standard methods for single level continuous and categorical data. Since these do not take any clustering or multilevel structures into account, valid imputation of incomplete multilevel data will typically require a user-supplied methods vector. The tables 7.2, 7.3 and 7.4 in van Buuren (2018, <span class="math inline">\(\S\)</span> 7.6, <span class="math inline">\(\S\)</span> 7.7 and <span class="math inline">\(\S\)</span> 7.8, respectively) provide an overview of the available methods to perform univariate multilevel imputation.</p>
<p>With the <code>predictorMatix</code> argument, <code>mice</code> users can define which columns should be used as predictors in each imputation model. The default predictor matrix is a square binary matrix with the variables to be imputed in the rows and the imputation model predictors in the columns. The default <code>predictorMatrix</code> will not be suitable for multilevel data. Univariate imputation methods for two-level data use other codes than <code>0</code> and <code>1</code>. In the predictor matrix, <code>-2</code> denotes the class variable, a value <code>1</code> indicates a fixed effect and a value <code>2</code> indicates a random effect. Additionally, the method <code>2l.pan</code> uses codes <code>3</code> and <code>4</code> to add class means to codes <code>1</code> and <code>2</code> respectively.</p>
<!-- 2l.bin, 2l.lmer, 2l.norm, 2l.pan, 2lonly.mean, 2lonly.norm and 2lonly.pmm use code -2 to indicate the class variable -->
<!-- -  2l.bin, 2l.lmer, 2l.norm and 2l.pan use code 2 to indicate the random effects -->
<!-- -  2l.pan uses codes 3 and 4 to add class means to codes 1 and 2 respectively -->
<p>FIMD, section 7.10</p>
<blockquote class="blockquote">
<p>Recipe for a level-1 target: 1. Define the most general analytic model to be applied to imputed data; 2. Select a 2l method that imputes close to the data; 3. Include all level-1 variables; 4. Include the disaggregated cluster means of all level-1 variables; 5. Include all level-1 interactions implied by the analytic model; 6. Include all level-2 predictors; 7. Include all level-2 interactions implied by the analytic model; 8. Include all cross-level interactions implied by the analytic model; 9. Include predictors related to the missingness and the target; 10. Exclude any terms involving the target</p>
</blockquote>
<blockquote class="blockquote">
<p>Recipe for a level-2 target: 1. Define the most general analytic model to be applied to imputed data; 2. Select a 2lonly method that imputes close to the data; 3. Include the cluster means of all level-1 variables; 4. Include the cluster means of all level-1 interactions; 5. Include all level-2 predictors; 6. Include all interactions of level-2 variables; 7. Include predictors related to the missingness and the target; 8. Exclude any terms involving the target</p>
</blockquote>
</section>
<section id="case-study" class="level1">
<h1>Case study</h1>
<p>Prerequisites: incomplete dataset and known multilevel modeling strategy (i.e.&nbsp;the most general analytic model to be applied to imputed data).</p>
<ol type="1">
<li>Load the data, make sure the variables are correctly formatted (e.g.&nbsp;numeric clustering variable)</li>
<li>Explore the missingness</li>
<li>Fix any cluster-level missingness determinately (note that <code>2l.only</code> methods do not work if there are inconsistencies, fix those first!)</li>
<li>Re-evaluate the missingness</li>
<li>Explore bivariate relations and associations with missingness indicators (optionally test the associations?)</li>
<li>For each incomplete variable:</li>
</ol>
<ul>
<li>Determine the imputation method</li>
<li>Choose imputation model predictors (see recipe)</li>
</ul>
<ol start="5" type="1">
<li>Set methods vector and predictor matrix</li>
<li>Impute the incomplete data</li>
<li>If error…</li>
<li>After successful run:</li>
</ol>
<ul>
<li>Evaluate convergence</li>
<li>Evaluate imputations</li>
</ul>
<ol start="9" type="1">
<li>Analyze and pool</li>
<li>For further multilevel model building, AICs could be pooled, how?</li>
</ol>
</section>
<section id="references" class="level1">
<h1>References</h1>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>